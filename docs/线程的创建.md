
## 进程（Process）和线程（Thread）的概念

计算机系统中有进程（Process）和线程（Thread）两个概念。

| |进程（Process）|线程（Thread）
-----|----|----
定义|资源分配的基本单位|调度的最小单位，进程内的一个执行单元
内存空间|独立的内存空间、文件描述符、环境变量等资源|共享进程的内存空间和资源
资源开销|创建、销毁和切换开销较大|创建、销毁和切换开销较小
通信方式|进程间通信需要操作系统支持（比如管道、消息队列、共享内存等）|线程间可以直接访问共享数据
稳定性|进程崩溃不会影响其他进程|线程崩溃可能导致整个进程崩溃
并发性|OK|OK
同步机制|不需要（因为内存独立）|需要同步机制（如互斥锁、信号量）来避免竞争

#### 进程的应用场景
- 需要高隔离型的任务（不同的应用程序）
- 需要独立内存空间的任务（多个独立的服务）
- 需要高稳定性的任务（一个进程崩溃不会影响其他进程）

#### 线程的应用场景
- 需要高效共享数据的任务（多线程服务器）
- 需要轻量级并发的任务（GUI/图形用户界面 应用程序中的后台任务）
- 需要频繁创建和销毁的任务（线程开销较小）


# RT-Thread 实时线程RTOS

由于嵌入式系统内存较少的特点，RTOS（实时操作系统）一般采用单进程多线程的设计。RT-Thread就是一个典型。

## 线程组成

RT-Thread中，线程由三个部分组成：
**线程代码（入口函数）**、**线程控制块**、**线程堆栈**

![线程结构](./figures/04Object_container.png)




#### 线程代码（入口函数）
线程控制块中的 entry 是线程的入口函数，它是线程实现预期功能的函数。线程的入口函数由用户设计实现，一般有以下两种代码形式：

- 无线循环结构（目的是为了让这个线程一直被系统循环调度运行，永不删除）
```C
void thread_entry(void *parameter)
{
    while(1)
    {
        /*等待事件发生*/
        /*让出CPU的使用权 避免死循环*/
        /*调用延时函数或者主动挂起*/
        ---
        /*处理事件*/
    }

}
```

- 顺序执行结构（“一次性”线程，用完就被系统删除，做些简单的工作）
```C
void thread_entry(void *parameter)
{
    /*处理事务1*/
    /*处理事务2*/
    ---
    /*处理事务N*/
}
```
#### 线程控制块（Thread Control Block, TCB）

线程控制块是操作系统用于管理线程的核心`数据结构`，它会存放线程的所有元信息，例如优先级、线程名称、线程状态等，也包括线程与线程之间连接用的链表结构，线程等待事件集合等，以及寄存器状态、栈指针、程序计数器（PC）等。

RT-Thread中线程控制块是由
`struct rt_thread{---};`和 `typedef struct rt_thread *rt_thread_t;` 来定义。具体查看`rtdef.h`。

```C
/**
 * Thread structure
 */
/* 线程控制块 */
struct rt_thread
{
    /* rt 对象 */
    char        name[RT_NAME_MAX];     /* 线程名称 */
    rt_uint8_t  type;                   /* 对象类型 */
    rt_uint8_t  flags;                  /* 标志位 */

    rt_list_t   list;                   /* 对象列表 */
    rt_list_t   tlist;                  /* 线程列表 */

    /* 栈指针与入口指针 */
    void       *sp;                      /* 栈指针 */
    void       *entry;                   /* 入口函数指针 */
    void       *parameter;              /* 参数 */
    void       *stack_addr;             /* 栈地址指针 */
    rt_uint32_t stack_size;            /* 栈大小 */

    /* 错误代码 */
    rt_err_t    error;                  /* 线程错误代码 */
    rt_uint8_t  stat;                   /* 线程状态 */

    /* 优先级 */
    rt_uint8_t  current_priority;    /* 当前优先级 */
    rt_uint8_t  init_priority;        /* 初始优先级 */
    rt_uint32_t number_mask;

    ......

    rt_ubase_t  init_tick;               /* 线程初始化计数值 */
    rt_ubase_t  remaining_tick;         /* 线程剩余计数值 */

    struct rt_timer thread_timer;      /* 内置线程定时器 */

    void (*cleanup)(struct rt_thread *tid);  /* 线程退出清除函数 */
    rt_uint32_t user_data;                      /* 用户数据 */
};
/* point to struct rt_thread */
/* 用来指向结构体 */
typedef struct rt_thread *rt_thread_t;
```


#### 线程栈

在RT-Thread中，**线程栈**是线程运行时用来存储局部变量、函数调用信息等的内存空间。简单来说，每个线程都有自己的“工作区”，这个工作区就是**线程栈**。

RT-Thread中每个线程都有独立的栈，当进行线程切换时，系统会将当前`线程的上下文`（线程执行时的环境，有各种变量和数据包括寄存器变量、堆栈信息、内存信息、函数调用、局部变量等）保存在**线程栈**中，当线程要恢复运行时，再从线程栈中读取上下文信息，恢复线程的运行。

> 栈是线程的私有空间，不同线程的栈互不干扰。<p>
线程栈≠线程所拥有的内存空间 

**线程栈**在形式上是一段连续的内存空间，我们可以定义一个数组或者申请一段动态内存来作为线程的栈。

即**线程栈**可以是静态分配的（固定大小），也可以是动态分配的（运行时从堆/heap中分配）。

> 为了避免线程栈占用太多内存空间，实际操作中，我们在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小。通过此命令，我们能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度。而后加上适当的余量形成最终的线程栈大小，最后对线程栈空间大小加以修改。



## 创建和删除线程（针对动态线程）

创建动态线程

```C
rt_thread_t rt_thread_create(
    const char* name,
    void (*entry)(void* parameter),
    void* parameter,
    rt_uint32_t stack_size,
    rt_uint8_t priority,
    rt_uint32_t tick
);
```
调用这个函数时，系统会从**动态堆内存**中分配一个线程句柄（线程控制块指针）以及按照参数中指定的`栈大小`从动态堆内存中分配相应的空间。分配出来的栈的空间是按照 `rtconfig.h` 中配置的 `RT_ALIGN_SIZE` 方式对齐。线程创建 `rt_thread_create()` 的参数和返回值见下表：

|**参数**  |**描述**                             |
|------------|----------------------------------------------------------------------------------------|
| name       | 线程的名称；线程名称的最大长度由 `rtconfig.h` 中的宏 `RT_NAME_MAX` 指定，多余部分会被自动截掉      |
| entry      | 线程入口函数             |
| parameter  | 线程入口函数参数（不需要传参可设为`RT_NULL`）                |
| stack_size | 线程栈大小，单位是字节                                                  |
| priority   | 线程的优先级。优先级范围根据系统配置情况（`rtconfig.h` 中的 `RT_THREAD_PRIORITY_MAX` 宏定义），如果支持的是 256 级优先级，那么范围是从 0\~255，数值越小优先级越高，0 代表最高优先级                                  |
| tick       | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
|**返回**  | ——                                    |
| thread     | 线程创建成功，返回线程句柄                                 |
| RT_NULL    | 线程创建失败                     |


对于一些使用 `rt_thread_create()` 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉：

```c
rt_err_t rt_thread_delete(rt_thread_t thread);
```

调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。

实际上，用 `rt_thread_delete()` 函数删除线程接口，仅仅是把相应的线程状态更改为 `RT_THREAD_CLOSE` 状态，然后放入到 `rt_thread_defunct` 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。

线程删除 `rt_thread_delete()` 接口的参数和返回值见下表：

|**参数**  |**描述**        |
|------------|------------------|
| thread     | 要删除的线程句柄/Handle （指向该线程控制块的指针）|
|**返回**  | ——               |
| RT_EOK     | 删除线程成功     |
| \-RT_ERROR | 删除线程失败     |

> 注：`rt_thread_create()` 和 `rt_thread_delete()` 函数仅在使能了系统动态堆时才有效（即 `RT_USING_HEAP` 宏定义已经定义了）。

## 初始化和脱离线程（针对静态线程）

```c
rt_err_t rt_thread_init(
    struct rt_thread* thread,
    const char* name,
    void (*entry)(void* parameter), void* parameter,
    void* stack_start, rt_uint32_t stack_size,
    rt_uint8_t priority, rt_uint32_t tick);
```

静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 `rt_thread_init()` 的参数和返回值见下表：

|**参数**   |**描述**     |
|-----------------|---------------------------------------------------------------------------|
| thread      | 线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址   |
| name        | 线程的名称；线程名称的最大长度由 `rtconfig.h` 中定义的 `RT_NAME_MAX` 宏指定，多余部分会被自动截掉    |
| entry       | 线程入口函数      |
| parameter   | 线程入口函数参数（不需要传参可设为`RT_NULL`）     |
| **stack_start** | **线程栈起始地址**     |
| stack_size  | 线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）                                                                                                           |
| priority    | 线程的优先级。优先级范围根据系统配置情况（`rtconfig.h` 中的 `RT_THREAD_PRIORITY_MAX` 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级        |
| tick        | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
|**返回**   | ——      |
| RT_EOK      | 线程创建成功      |
| \-RT_ERROR  | 线程创建失败     |

对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将使线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下：

```c
rt_err_t rt_thread_detach (rt_thread_t thread);
```

线程脱离接口 `rt_thread_detach()` 的参数和返回值见下表：

|**参数**  |**描述**                                                  |
|------------|------------------------------------------------------------|
| thread     | 线程句柄，它应该是由 `rt_thread_init()` 进行初始化的线程句柄。 |
|**返回**  | ——                                                         |
| RT_EOK     | 线程脱离成功                                               |
| \-RT_ERROR | 线程脱离失败                                               |

这个函数接口是和 `rt_thread_delete()` 函数相对应的， `rt_thread_delete()` 函数操作的对象是 `rt_thread_create()` 创建的句柄，而 `rt_thread_detach()` 函数操作的对象是使用 `rt_thread_init()` 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。



## 启动线程
创建/初始化线程后，我们还需要调用`rt_thread_startup()`让线程进入**就绪状态**
```C
rt_err_t rt_thread_startup(rt_thread_t thread);
```
当调用这个函数时，将把线程的状态更改为就绪状态，并放到**相应优先级队列**中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。
线程启动接口 `rt_thread_startup()` 的参数和返回值见下表：

|**参数**  |**描述**                 |
|------------|-----------------------------------------|
| thread     | 线程句柄 |
|**返回**  | ——                          |
| RT_EOK     | 线程启动成功                 |
| \-RT_ERROR | 线程启动失败      |



> 注：静态线程 VS 动态线程<p>
本质上就是资源分配形式的差别。动态线程是从`heep`中动态分配而来的，而静态线程是一开始就分配好的空间。如果RAM有片内RAM和片外RAM，而且`heap`在片外RAM上，则动态线程运行效率就会低（片外RAM运行效率 低于 片内RAM运行效率）。