
## 进程（Process）和线程（Thread）的概念

计算机系统中有进程（Process）和线程（Thread）两个概念。

| |进程（Process）|线程（Thread）
-----|----|----
定义|资源分配的基本单位|调度的最小单位，进程内的一个执行单元
内存空间|独立的内存空间、文件描述符、环境变量等资源|共享进程的内存空间和资源
资源开销|创建、销毁和切换开销较大|创建、销毁和切换开销较小
通信方式|进程间通信需要操作系统支持（比如管道、消息队列、共享内存等）|线程间可以直接访问共享数据
稳定性|进程崩溃不会影响其他进程|线程崩溃可能导致整个进程崩溃
并发性|OK|OK
同步机制|不需要（因为内存独立）|需要同步机制（如互斥锁、信号量）来避免竞争

#### 进程的应用场景
- 需要高隔离型的任务（不同的应用程序）
- 需要独立内存空间的任务（多个独立的服务）
- 需要高稳定性的任务（一个进程崩溃不会影响其他进程）

#### 线程的应用场景
- 需要高效共享数据的任务（多线程服务器）
- 需要轻量级并发的任务（GUI/图形用户界面 应用程序中的后台任务）
- 需要频繁创建和销毁的任务（线程开销较小）


# RT-Thread 实时线程RTOS

由于嵌入式系统内存较少的特点，RTOS（实时操作系统）一般采用单进程多线程的设计。RT-Thread就是一个典型。

RT-Thread 线程管理的主要功能是对线程进行管理和调度，系统中总共存在两类线程，分别是系统线程和用户线程，系统线程是由 RT-Thread 内核创建的线程，用户线程是由应用程序创建的线程，这两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除。

RT-Thread 的线程调度器是**抢占式**的，主要的工作就是从就绪线程列表中查找最高优先级线程，保证最高优先级的线程能够被运行，最高优先级的任务一旦就绪，总能得到 CPU 的使用权。

当一个运行着的线程使一个比它优先级高的线程满足运行条件，当前线程的 CPU 使用权就被剥夺了，或者说**让出**了，高优先级的线程立刻得到了 CPU 的使用权。

> 注：这个满足运行条件还挺“苛刻”的，一般得有`rt_thread_mdelay()`来使线程处于`挂起状态`，从而让出CPU。

如果是**中断服务程序**使一个高优先级的线程满足运行条件，中断完成时，被中断的线程挂起，优先级高的线程开始运行。

当调度器调度线程切换时，先将当前线程上下文保存起来，当再切回到这个线程时，线程调度器将该线程的上下文信息恢复。


## 线程组成

如下图所示，在RT-Thread中，线程由三个部分组成：
**线程代码（入口函数）**、**线程控制块**、**线程堆栈**。

![线程结构](./figures/04Object_container.png)




#### 线程代码（入口函数）
线程控制块中的 entry 是线程的入口函数，它是线程实现预期功能的函数。线程的入口函数由用户设计实现，一般有以下两种代码形式：

- 无线循环结构（目的是为了让这个线程一直被系统循环调度运行，永不删除）
```C
void thread_entry(void *parameter)
{
    while(1)
    {
        /*等待事件发生*/
        /*让出CPU的使用权 避免死循环*/
        /*调用延时函数或者主动挂起*/
        ---
        /*处理事件*/
    }

}
```

- 顺序执行结构（“一次性”线程，用完就被系统删除，做些简单的工作）
```C
void thread_entry(void *parameter)
{
    /*处理事务1*/
    /*处理事务2*/
    ---
    /*处理事务N*/
}
```
#### 线程控制块（Thread Control Block, TCB）

线程控制块是操作系统用于管理线程的核心`数据结构`，它会存放线程的所有元信息，例如优先级、线程名称、线程状态等，也包括线程与线程之间连接用的链表结构，线程等待事件集合等，以及寄存器状态、栈指针、程序计数器（PC）等。

RT-Thread中线程控制块是由
`struct rt_thread{---};`和 `typedef struct rt_thread *rt_thread_t;` 来定义。具体查看`rtdef.h`。

```C
/**
 * Thread structure
 */
/* 线程控制块 */
struct rt_thread
{
    /* rt 对象 */
    char        name[RT_NAME_MAX];     /* 线程名称 */
    rt_uint8_t  type;                   /* 对象类型 */
    rt_uint8_t  flags;                  /* 标志位 */

    rt_list_t   list;                   /* 对象列表 */
    rt_list_t   tlist;                  /* 线程列表 */

    /* 栈指针与入口指针 */
    void       *sp;                      /* 栈指针 */
    void       *entry;                   /* 入口函数指针 */
    void       *parameter;              /* 参数 */
    void       *stack_addr;             /* 栈地址指针 */
    rt_uint32_t stack_size;            /* 栈大小 */

    /* 错误代码 */
    rt_err_t    error;                  /* 线程错误代码 */
    rt_uint8_t  stat;                   /* 线程状态 */

    /* 优先级 */
    rt_uint8_t  current_priority;    /* 当前优先级 */
    rt_uint8_t  init_priority;        /* 初始优先级 */
    rt_uint32_t number_mask;

    ......

    rt_ubase_t  init_tick;               /* 线程初始化计数值 */
    rt_ubase_t  remaining_tick;         /* 线程剩余计数值 */

    struct rt_timer thread_timer;      /* 内置线程定时器 */

    void (*cleanup)(struct rt_thread *tid);  /* 线程退出清除函数 */
    rt_uint32_t user_data;                      /* 用户数据 */
};
/* point to struct rt_thread */
/* 用来指向结构体 */
typedef struct rt_thread *rt_thread_t;
```


#### 线程栈

在RT-Thread中，**线程栈**是线程运行时用来存储局部变量、函数调用信息等的内存空间。简单来说，每个线程都有自己的“工作区”，这个工作区就是**线程栈**。

RT-Thread中每个线程都有独立的栈，当进行线程切换时，系统会将当前`线程的上下文`（线程执行时的环境，有各种变量和数据包括寄存器变量、堆栈信息、内存信息、函数调用、局部变量等）保存在**线程栈**中，当线程要恢复运行时，再从线程栈中读取上下文信息，恢复线程的运行。

> 注：栈是线程的私有空间，不同线程的栈互不干扰。<p>
线程栈≠线程所拥有的内存空间 

**线程栈**在形式上是一段连续的内存空间，我们可以定义一个数组或者申请一段动态内存来作为线程的栈。

即**线程栈**可以是静态分配的（固定大小），也可以是动态分配的（运行时从堆/heap中分配）。

> 为了避免线程栈占用太多内存空间，实际操作中，我们在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小。通过此命令，我们能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度。而后加上适当的余量形成最终的线程栈大小，最后对线程栈空间大小加以修改。



## 创建和删除线程（针对动态线程）
**`rt_thread_create()`和`rt_thread_delete()`**

### 创建动态线程

```C
rt_thread_t rt_thread_create(
    const char* name,
    void (*entry)(void* parameter),
    void* parameter,
    rt_uint32_t stack_size,
    rt_uint8_t priority,
    rt_uint32_t tick
);
```
调用这个函数时，系统会从**动态堆内存**中分配一个线程句柄（线程控制块指针）以及按照参数中指定的`栈大小`从动态堆内存中分配相应的空间。分配出来的栈的空间是按照 `rtconfig.h` 中配置的 `RT_ALIGN_SIZE` 方式对齐。线程创建 `rt_thread_create()` 的参数和返回值见下表：

|**参数**  |**描述**                             |
|------------|----------------------------------------------------------------------------------------|
| name       | 线程的名称；线程名称的最大长度由 `rtconfig.h` 中的宏 `RT_NAME_MAX` 指定，多余部分会被自动截掉      |
| entry      | 线程入口函数             |
| parameter  | 线程入口函数参数（不需要传参可设为`RT_NULL`）                |
| stack_size | 线程栈大小，单位是字节                                                  |
| priority   | 线程的优先级。优先级范围根据系统配置情况（`rtconfig.h` 中的 `RT_THREAD_PRIORITY_MAX` 宏定义），如果支持的是 256 级优先级，那么范围是从 0\~255，数值越小优先级越高，0 代表最高优先级                                  |
| tick       | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
|**返回**  | ——                                    |
| thread     | 线程创建成功，返回线程句柄                                 |
| RT_NULL    | 线程创建失败                     |


### 删除动态线程
对于一些使用 `rt_thread_create()` 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口`rt_thread_delete() `来从系统中把线程完全删除掉：

```c
rt_err_t rt_thread_delete(rt_thread_t thread);
```

调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。

实际上，用 `rt_thread_delete()` 函数删除线程接口，仅仅是把相应的线程状态更改为 `RT_THREAD_CLOSE` 状态，然后放入到 `rt_thread_defunct` 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。

线程删除 `rt_thread_delete()` 接口的参数和返回值见下表：

|**参数**  |**描述**        |
|------------|------------------|
| thread     | 要删除的线程句柄/Handle （指向该线程控制块的指针）|
|**返回**  | ——               |
| RT_EOK     | 删除线程成功     |
| \-RT_ERROR | 删除线程失败     |

> 注：`rt_thread_create()` 和 `rt_thread_delete()` 函数仅在使能了系统动态堆时才有效（即 `RT_USING_HEAP` 宏定义已经定义了）。

## 初始化和脱离线程（针对静态线程）
**`rt_thread_init()`和`rt_thread_detach()`**

### 初始化静态线程

```c
rt_err_t rt_thread_init(
    struct rt_thread* thread,
    const char* name,
    void (*entry)(void* parameter), void* parameter,
    void* stack_start, rt_uint32_t stack_size,
    rt_uint8_t priority, rt_uint32_t tick);
```

静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 `rt_thread_init()` 的参数和返回值见下表：

|**参数**   |**描述**     |
|-----------------|---------------------------------------------------------------------------|
| thread      | 线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址   |
| name        | 线程的名称；线程名称的最大长度由 `rtconfig.h` 中定义的 `RT_NAME_MAX` 宏指定，多余部分会被自动截掉    |
| entry       | 线程入口函数      |
| parameter   | 线程入口函数参数（不需要传参可设为`RT_NULL`）     |
| **stack_start** | **线程栈起始地址**     |
| stack_size  | 线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）                                                                                                           |
| priority    | 线程的优先级。优先级范围根据系统配置情况（`rtconfig.h` 中的 `RT_THREAD_PRIORITY_MAX` 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级        |
| tick        | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
|**返回**   | ——      |
| RT_EOK      | 线程创建成功      |
| \-RT_ERROR  | 线程创建失败     |

### 脱离静态线程
对于用 `rt_thread_init()` 初始化的线程，使用 `rt_thread_detach()` 将使线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下：

```c
rt_err_t rt_thread_detach (rt_thread_t thread);
```

线程脱离接口 `rt_thread_detach()` 的参数和返回值见下表：

|**参数**  |**描述**                                                  |
|------------|------------------------------------------------------------|
| thread     | 线程句柄，它应该是由 `rt_thread_init()` 进行初始化的线程句柄。 |
|**返回**  | ——                                                         |
| RT_EOK     | 线程脱离成功                                               |
| \-RT_ERROR | 线程脱离失败                                               |

这个函数接口是和 `rt_thread_delete()` 函数相对应的， `rt_thread_delete()` 函数操作的对象是 `rt_thread_create()` 创建的句柄，而 `rt_thread_detach()` 函数操作的对象是使用 `rt_thread_init()` 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。


> 注：静态线程 VS 动态线程<p>
本质上就是资源分配形式的差别。动态线程是从`heep`中动态分配而来的，而静态线程是一开始就分配好的空间。如果RAM有片内RAM和片外RAM，而且`heap`在片外RAM上，则动态线程运行效率就会低（片外RAM运行效率 低于 片内RAM运行效率）。


## 线程状态

线程运行的过程中，同一时间内只允许一个线程在处理器中运行，从运行的过程上划分，线程有多种不同的运行状态。在 RT-Thread 中，线程包含五种状态，操作系统会自动根据它运行的情况来动态调整它的状态。

RT-Thread 中线程的五种状态，如下表所示：

|  状态  |  描述     |  宏定义|
|--------|---------------|-----|
| 初始状态 | 当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。（线程还未使用`rt_thread_setup()`）    |`RT_THREAD_INIT` |
| 就绪状态 | 在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。| `RT_THREAD_READY`         |
| 运行状态 | 线程当前正在运行。在单核系统中，只有 `rt_thread_self()` 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。| `RT_THREAD_RUNNING` |
| 挂起状态 | 也称阻塞态。它可能因为**资源不可用**而挂起等待，或线程**主动延时**一段时间而挂起，或从就绪状态调用`rt_thread_suspend()`而挂起。在挂起状态下，线程不参与调度。| `RT_THREAD_SUSPEND`                           |
| 关闭状态 | 当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。| `RT_THREAD_CLOSE`    |

### 状态切换

RT-Thread有一系列的 SCI/API 来实现线程状态的切换。状态关系的转换如下图所示：

![线程状态切换图](./figures/04thread_sta.png)

>- API（Application Programming Interface，应用程序编程接口） <p> 
>- SCI（System Call Interface，系统调用接口）



## 启动线程
创建/初始化线程后，我们还需要调用`rt_thread_startup()`让线程从**初始状态**进入**就绪状态**。
```C
rt_err_t rt_thread_startup(rt_thread_t thread);
```
当调用这个函数时，将把线程的状态更改为就绪状态，并放到**相应优先级队列**中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。
线程启动接口 `rt_thread_startup()` 的参数和返回值见下表：

|**参数**  |**描述**                 |
|------------|-----------------------------------------|
| thread     | 线程句柄 |
|**返回**  | ——                          |
| RT_EOK     | 线程启动成功                 |
| \-RT_ERROR | 线程启动失败      |


## 挂起线程






## 系统线程

我们知道在RT-Thread中，有由用户程序调用线程管理接口创建的线程——用户线程，也有系统本身创建的线程——系统线程。在 RT-Thread 内核中的系统线程有空闲线程和主线程。

### 空闲线程

**空闲线程（idle）**是系统创建的**最低优先级**的线程，线程状态永远为**就绪态**。当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个死循环，且永远不能被挂起。另外，空闲线程在 RT-Thread 也有着它的特殊用途：

若某线程运行完毕，系统将自动删除线程：自动执行 `rt_thread_exit()` 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 `rt_thread_defunct` 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。

空闲线程也提供了接口来运行用户设置的**钩子函数**，在空闲线程运行时会调用该钩子函数，适合处理功耗管理、看门狗喂狗等工作。

> 重要：空闲线程必须有得到执行的机会，即**其他线程不允许一直`while(1)`死循环，必须调用具有阻塞性质的函数（例如`rt_thread_delay()`和`rt_thread_mdelay()`）；否则例如线程删除、回收等操作将无法得到正确执行**。


### 主线程

在系统启动时，系统会创建 **main 线程**，它的入口函数为 `main_thread_entry()`，用户的应用入口函数 `main()` 就是从这里真正开始的，系统调度器启动后，main 线程就开始运行，过程如下，用户可以在 `main()` 函数里添加自己的应用程序初始化代码。
```rust
SystemInit()
    ↓
$Sub$$main()
    ↓进入
rtthread_startup()
    ↓进入
rt_application_init()
    ↓调用
main_thread_entry()
    ↓调用
$Super$$main() / main()
用户主函数
```
