## 线程同步的概念

同步 ≠ 同时，同步是指多个线程按预定的**先后次序**进行运行，同时是指同一个时间多个线程一起运行。

假定某个共享内存块A，如果它的访问不具备排他性，则它会同时被`线程1`和`线程2`访问，那么就有可能导致数据一致性的问题。比如`线程1`按位写入数据0xff，而`线程2`读取数据。如果线程1才写入了部分数据（0xf0），`线程2`就读走了，那么读取的数据就是错的。这样会造成系统后续的一系列问题。所以线程对共享内存的访问必须是具有排他性的。`线程1`和`线程2`互斥访问共享内存A。显然，这又会涉及到一个访问次序问题。

那系统如何确定`线程1`和`线程2`的访问次序呢？即如何实现这个**同步**呢？RT-Thread 提供了多种方法：信号量（samaphore）、互斥量（mutex）和事件集（event）。

## 信号量

简单的例子：停车！

停车场管理员就相当于信号量，管理员手中空车位的个数就是信号量的值（非负数，动态变化）；停车位相当于公共资源（临界区），车辆相当于线程。车辆通过获得管理员的允许取得停车位，就类似于线程通过获得信号量访问公共资源。

### 信号量的工作机制

信号量是一种轻型的用于解决线程间同步问题的内核对象，线程可以获取或释放它，从而达到同步或者互斥的目的。

### 信号量控制块
在 RT-Thread 中，信号量控制块是操作系统用于管理信号量的一个数据结构，由结构体 struct rt_semaphore 表示。另外一种 C 表达方式 rt_sem_t，表示的是信号量的句柄，在 C 语言中的实现是指向信号量控制块的指针。信号量控制块结构的详细定义如下：
```C
struct rt_semaphore
{
   struct rt_ipc_object parent;  /* 继承自 ipc_object 类 */
   rt_uint16_t value;            /* 信号量的值 最大65535*/
};
/* rt_sem_t 是指向 semaphore 结构体的指针类型 */
typedef struct rt_semaphore* rt_sem_t;
```

### 信号量的管理方式

信号量控制块中含有信号量相关的重要参数，在信号量各种状态间起到纽带的作用。信号量相关接口如下图所示，对一个信号量的操作包含：创建 / 初始化信号量、获取信号量、释放信号量、删除 / 脱离信号量。

![信号量相关接口](figures/06sem_ops.png)

#### 创建和删除信号量

当创建一个信号量时，内核首先创建一个信号量控制块，然后对该控制块进行基本的初始化工作，创建信号量使用下面的函数接口：

```c
 rt_sem_t rt_sem_create(const char *name,
                        rt_uint32_t value,
                        rt_uint8_t flag);
```

当调用这个函数时，系统将先从对象管理器中分配一个 `semaphore` 对象，并初始化这个对象，然后初始化父类 `IPC` 对象以及与 `semaphore` 相关的部分。在创建信号量指定的参数中，**信号量标志参数**`flag`决定了当信号量不可用时，多个线程等待的排队方式。当选择 `RT_IPC_FLAG_FIFO`（先进先出）方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；当选择 `RT_IPC_FLAG_PRIO`（优先级等待）方式时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。

> [!NOTE]
> 注：RT_IPC_FLAG_FIFO 属于**非实时调度方式**，除非应用程序非常在意先来后到，并且你清楚地明白所有涉及到该信号量的线程都将会变为非实时线程，方可使用 RT_IPC_FLAG_FIFO，否则建议采用 RT_IPC_FLAG_PRIO，即确保线程的实时性。

下表描述了该函数的输入参数与返回值：

|**参数**          |**描述**                                                         |
|--------------------|-------------------------------------------------------------------|
| name               | 信号量名称                                                        |
| value              | 信号量初始值                                                      |
| flag               | 信号量标志参数，它可以取如下数值： RT_IPC_FLAG_FIFO （先进先出）或 RT_IPC_FLAG_PRIO （优先级等待）|
|**返回**          | ——                                                                |
| RT_NULL            | 创建失败                                                          |
| 信号量的控制块指针 | 创建成功                                                          |

系统不再使用信号量时，可通过删除信号量以释放系统资源，适用于动态创建的信号量。删除信号量使用下面的函数接口：

```c
rt_err_t rt_sem_delete(rt_sem_t sem);
```

调用这个函数时，系统将删除这个信号量。如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 -
RT_ERROR），然后再释放信号量的内存资源。下表描述了该函数的输入参数与返回值：

|**参数**|**描述**                        |
|----------|----------------------------------|
| sem      | rt_sem_create() 创建的信号量对象 |
|**返回**| ——                               |
| RT_EOK   | 删除成功                         |

#### 初始化和脱离信号量

对于静态信号量对象，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上，此时使用信号量就不再需要使用 rt_sem_create 接口来创建它，而只需在使用前对它进行初始化即可。初始化信号量对象可使用下面的函数接口：

```c
rt_err_t rt_sem_init(rt_sem_t       sem,
                    const char     *name,
                    rt_uint32_t    value,
                    rt_uint8_t     flag)
```

当调用这个函数时，系统将对这个 semaphore 对象进行初始化，然后初始化 IPC 对象以及与
semaphore 相关的部分。信号量标志可用上面创建信号量函数里提到的标志。下表描述了该函数的输入参数与返回值：

|**参数**|**描述**                                                         |
|----------|-------------------------------------------------------------------|
| sem      | 信号量对象的句柄                                                  |
| name     | 信号量名称                                                        |
| value    | 信号量初始值                                                      |
| flag     | 信号量标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO |
|**返回**| ——                                                                |
| RT_EOK   | 初始化成功                                                        |

脱离信号量就是让信号量对象从内核对象管理器中脱离，适用于静态初始化的信号量。脱离信号量使用下面的函数接口：

```c
rt_err_t rt_sem_detach(rt_sem_t sem);
```

使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中脱离。原来挂起在信号量上的等待线程将获得 - RT_ERROR 的返回值。下表描述了该函数的输入参数与返回值：

|**参数**|**描述**        |
|----------|------------------|
| sem      | 信号量对象的句柄 |
|**返回**| ——               |
| RT_EOK   | 脱离成功         |

#### 获取信号量

线程通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1，获取信号量使用下面的函数接口：

```c
rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);
```

在调用这个函数时，如果信号量的值等于零，那么说明当前信号量资源实例不可用，申请该信号量的线程将根据 time 参数的情况选择直接返回、或挂起等待一段时间、或永久等待，直到其他线程或中断释放该信号量。如果在参数 time 指定的时间内依然得不到信号量，线程将超时返回，返回值是 - RT_ETIMEOUT。下表描述了该函数的输入参数与返回值：

|**参数**     |**描述**                                         |
|---------------|---------------------------------------------------|
| sem           | 信号量对象的句柄                                  |
| time          | 指定的等待时间，单位是操作系统时钟节拍（OS Tick） |
|**返回**     | ——                                                |
| RT_EOK        | 成功获得信号量                                    |
| \-RT_ETIMEOUT | 超时依然未获得信号量                              |
| \-RT_ERROR    | 其他错误                                          |

#### 无等待获取信号量

当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量，无等待获取信号量使用下面的函数接口：

```c
rt_err_t rt_sem_trytake(rt_sem_t sem);
```

这个函数与 `rt_sem_take(sem, RT_WAITING_NO)` 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - RT_ETIMEOUT。下表描述了该函数的输入参数与返回值：

|**参数**     |**描述**        |
|---------------|------------------|
| sem           | 信号量对象的句柄 |
|**返回**     | ——               |
| RT_EOK        | 成功获得信号量   |
| \-RT_ETIMEOUT | 获取失败         |

#### 释放信号量

释放信号量可以唤醒挂起在该信号量上的线程。释放信号量使用下面的函数接口：

```c
rt_err_t rt_sem_release(rt_sem_t sem);
```

例如当信号量的值等于零时，并且有线程等待这个信号量时，释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则将把信号量的值加 1。下表描述了该函数的输入参数与返回值：

|**参数**|**描述**        |
|----------|------------------|
| sem      | 信号量对象的句柄 |
|**返回**| ——               |
| RT_EOK   | 成功释放信号量   |

### 信号量应用示例

这是一个信号量使用例程，该例程创建了一个动态信号量，初始化两个线程，一个线程发送信号量，一个线程接收到信号量后，执行相应的操作。如下代码所示：

> 注意：RT-Thread 5.0 及更高的版本将 `ALIGN` 关键字改成了 `rt_align`，使用时注意修改。
